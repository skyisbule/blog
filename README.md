# 杂谈
姑且记录一下自己看过的想记下来的东西.
# bit map 
bitmap是一种数据压缩算法，用于大量数字排序、判重、快速查找、去重等领域，核心思想是用bit位代表数字是否存在，如12378可表示为11100011，这样存储相同的数据量的时候，所需要用到的内存就会少很多，具体实现为：new Byte[n/32 + 1],存储的数据为0~31为array[0],32~63为array[1]，以此类推。
# bloom filter
布隆过滤器，布隆过滤器是一种判重的算法，其核心思想是通过hash来确定输入元素是否存在在集合里，具体做法为，创建一个大的bit[](根据情况也可能会分片)，然后通过n个hash算法算出输入元素的n个hash值，再将bit数组里的相应的位数置为1，添加操作便完成了，判断元素是否存在时，就仍然通过那n个hash算法算出n个hash值，再判断相应的位数上的值是不是1，如果全都是1则元素可能存在在集合里（因为存在冲突），但如果只要有1个位不为1，那么该元素一定不存在在集合里。布隆过滤器只存特征而不存数据本身，所以内存占用会比hashset少非常非常多，这就是它最核心的优点。<br>
另外值得一说的是，布隆过滤器的精准度由bit数组的大小、hash算法的效率、hash算法的个数决定，需要根据场景的不同，选择合适的算法以及大小，甚至在必要的情况下，对bit数组进行分片处理。
# hash一致性
用于机器或库表的水平拓展的技术，让请求可以通过这个算法落到相应的机器（服务）上。比起普通的如：id跟8取余的分表方式，它能够很好的处理机器的增加和减少的情况。
# threadLocal
是一个普通的java类，但不同点在于，它更像是一个变量，（不同于类成员的全局变量、方法内的局部变量）它的作用域为线程，每个线程对它执行set后再get，只能看到自己set的值，于是，它便达到了线程安全的单例。
# 数据库mvcc机制
mvcc是一种多版本快照度的机制，用于提高并发事务下的**读效率**，innodb的做法是为每一行数据增加两个隐藏列，最后写事务id和rollbackptr，在一个事务开始时，事务会获取目前已提交的最大的事务id，作为自己的read view，即可视化id，之后在读取数据时，无论数据行有没有被加锁，都会去读，在读到后通过数据的事务id来判断此条数据是否是在本事务之后修改/创建的，如果发现rollbackptr不为空，那么证明次数据被修改过，那么就会通过这个指针去读undo日志，把旧值读出来，替换，返回给客户端，如果ptr为空，也就是说这条数据是新创建的，那么无视掉它就可。                  
这样既可在数据被加锁的时候仍然可以读取数据，从而提高系统吞吐量。但是它有两种不适合的场景：1.无事务场景2.每次事务会波及到大多数数据的场景
